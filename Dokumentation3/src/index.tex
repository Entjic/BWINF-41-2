\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Lösungsidee}\label{sec:losungsidee}
Um Pfandkuchenstapel zu sortieren, wird die Technik des Dynamic Programmings verwendet.
Idee ist es, das Problem, also den zu sortierenden Pfandkuchenstapel in identische Teilprobleme zu zerlegen.
Im Kontext der Aufgabe bedeutet das, an allen möglichen Indizes die Wende-und-Essoperation beginnen zu lassen.
Der jeweilige Index der Wende-und-Essoperation wird gemerkt.
Dieses Verfahren wird so lange wiederholt, bis der Pfandkuchenstapel sortiert ist.
Die möglichen Abfolgen von Wende-und-Essoperationen zur Sortierung eines Pfandkuchenstapels werden gesammelt
und abschlie{\ss}end derjenige gewählt, der die wenigsten Wende-und-Essoperationen benötigt.
Danach wird sich der aktuelle Pfandkuchenstapel und die jeweilige beste gefundene Lösung gemerkt.
Zu Beginn eines jeden Rekursionsschritts wird überprüft, ob nicht genau dieser Pfandkuchenstapel bereits gelöst wurde.
Ist der Pfandkuchenstapel bereits gelöst worden, so wird darauf verzichtet diesen wieder in alle möglichen Pfandkuchenstapel
aufzuteilen und es wird einfach die Zugfolge des gelösten Pfandkuchenstapels verwendet. \\
Dieses Verfahren garantiert einerseits, dass die Zugfolge optimal kurz ist, und zugleich nicht unnötig
oft derselbe Pfandkuchenstapel gelöst wird. \\
Um die PWUE-Zahl einer Pfandkuchenstapelhöhe zu generieren müssen alle Pfandkuchenstapel der besagten Höhe generiert,
sortiert und abschlie{\ss}end bezüglich der Länge ihrer Zufolge evaluiert werden.
Problematisch hierbei ist die schiere Menge der zu prüfenden Pfandkuchenstapel, sowie die Menge der Einträge, die sich,
infolge des Dynamic Programming Ansatzes, gemerkt werden müssen.
Für die Anzahl der zu prüfenden Pfandkuchenstapel gilt $h!$ wobei $h$ die Höhe der betrachteten Pfandkuchenstapel ist.
Um die zu merkende Datenmenge zu reduzieren, wird die Art und Weise wie Pfandkuchenstapel gelöst werden modifiziert.
Ziel ist es nun nicht mehr, die Zugfolge zu finden, sondern lediglich die Anzahl der nötigen Wende-und-Essoperationen.
Zudem werden die PWUE-Zahlen dynamisch generiert.
Sucht man also bspw die PWUE-Zahl der Höhe 7, so wird zunächst die PWUE-Zahl der Höhe 1, dann 2, dann 3, etc generiert,
und dementsprechend auch alle Pfandkuchenstapel der Höhe 1, 2, 3 etc.
Dieser Bottom-Up Ansatz hat den Vorteil, dass man sich sicher sein kann, dass alle Pfandkuchenstapel der vorherigen
Höhen bereits gelöst wurden.
Im vorher verwendeten Top-Down Ansatz würde man bei fehlenden Einträgen davon ausgehen, dass diese schlicht noch nicht
berechnet wurden und deswegen fehlen.
Jetzt kann aber davon ausgegangen werden, dass diese absichtlich fehlen,
schlie{\ss}lich wurden ja alle vorherigen Pfandkuchenstapel gelöst.
Dadurch kann durch die \textit{absenz von Einträgen} Information ausgedrückt werden, ohne kostbaren
Arbeitsspeicher aufzuwenden.
Konkret werden, nachdem die PWUE-Zahl einer Zahl $n$ ermittelt wurde, alle Einträge gelöscht, welche eine so kurze Zugfolge
aufweisen, sodass sie für die PWUE-Zahl von $n + 1$ nicht relevant sind.
Die Zugfolge ist genau dann zu kurz, wenn sie kleiner als $n - 2$ ist.
Beim Lösen eines Pfandkuchenstapels der Höhe $n$ werden nun alle Pfandkuchenstapel erzeugt,
welche durch eine einzige Wende-und-Essoperation erreichbar sind.
Diese haben demnach die Höhe $n - 1$.
Ist einer der resultierenden Pfandkuchenstapel nicht gemerkt, so kann davon ausgegangen werden, dass der ursprüngliche
Pfandkuchen auch nicht relevant für die PWUE-Betrachtung ist, weil er genau einen Zug
mehr braucht als ein Stapel der weniger als $PWUE(n - 1) - 2$ Operationen benötigt.
Der ursprüngliche Pfandkuchen braucht in dem Fall also maximal $PWUE(n - 1) - 2$ Operationen um sortiert zu werden.
Da $PWUE(n + 1) >= PWUE(n)$ muss $PWUE(n) >= PWUE(n - 1)$ gelten.
Um einen Einfluss auf $PWUE(n)$ zu nehmen muss die Anzahl


\section{Umsetzung}\label{sec:umsetzung}
Die Implementierung erfolgt in Java 17.

\section{Beispiele}\label{sec:beispiele}
\subsection{Beispiel Dateien}\label{subsec:beispiel-dateien}
Es folgen die Pfandkuchenstapel der Beispieldateien und die jeweilige Programmausgabe.
pancake0.txt \\
Input pancake stack PancakeStackData{pancakes=[1, 5, 4, 2, 3]} \\
Shortest order of flipping operations with length 2 \\
Order of operations [0, 0] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[3, 2, 1]}, pancakes=PancakeStackData{pancakes=[5, 4, 2]}} \\
Map entry count 9 \\
pancake1.txt \\
Input pancake stack PancakeStackData{pancakes=[5, 2, 4, 7, 1, 3, 6]} \\
Shortest order of flipping operations with length 3 \\
Order of operations [1, 1, 2] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[5, 4, 3, 1]}} \\
Map entry count 69 \\
pancake2.txt \\
Input pancake stack PancakeStackData{pancakes=[2, 4, 6, 3, 5, 7, 1, 8]} \\
Shortest order of flipping operations with length 4 \\
Order of operations [4, 5, 3, 0] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[8, 7, 6, 4]}} \\
Map entry count 147 \\
pancake3.txt \\
Input pancake stack PancakeStackData{pancakes=[6, 3, 7, 9, 2, 8, 4, 11, 1, 10, 5]} \\
Shortest order of flipping operations with length 6 \\
Order of operations [0, 5, 8, 2, 0, 1] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[11, 10, 9, 7, 3]}} \\
Map entry count 3067 \\
pancake4.txt \\
Input pancake stack PancakeStackData{pancakes=[2, 8, 3, 9, 12, 13, 1, 6, 10, 5, 11, 4, 7]} \\
Shortest order of flipping operations with length 7 \\
Order of operations [1, 7, 2, 1, 0, 6, 2] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[6, 5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[13, 12, 11, 10, 6, 3]}} \\
Map entry count 26571 \\
pancake5.txt \\
Input pancake stack PancakeStackData{pancakes=[11, 5, 6, 12, 1, 14, 9, 7, 3, 2, 8, 10, 13, 4]} \\
Shortest order of flipping operations with length 6 \\
Order of operations [13, 0, 5, 2, 5, 3] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[8, 7, 6, 5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[13, 10, 9, 6, 5, 3, 2, 1]}} \\
Map entry count 87663 \\
pancake6.txt \\
Input pancake stack PancakeStackData{pancakes=[6, 10, 5, 9, 3, 11, 7, 15, 1, 2, 13, 12, 4, 8, 14]} \\
Shortest order of flipping operations with length 8 \\
Order of operations [1, 4, 6, 2, 7, 3, 0, 0] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[7, 6, 5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[14, 11, 9, 5, 4, 2, 1]}} \\
Map entry count 293466 \\
pancake7.txt \\
Input pancake stack PancakeStackData{pancakes=[11, 16, 14, 1, 9, 12, 4, 2, 6, 13, 7, 3, 15, 10, 5, 8]} \\
Shortest order of flipping operations with length 8 \\
Order of operations [5, 0, 0, 8, 10, 5, 2, 3] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[8, 7, 6, 5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[16, 14, 10, 9, 8, 7, 6, 2]}} \\
Map entry count 1057379 \\
\subsection{Weitere Pfandkuchenstapel}\label{subsec:weitere-pfandkuchenstapel}
Höhe 18 \\
Input pancake stack PancakeStackData{pancakes=[13, 16, 3, 7, 15, 1, 2, 18, 9, 4, 5, 11, 6, 12, 14, 8, 10, 17]} \\
Shortest order of flipping operations with length 9 \\
Order of operations [8, 6, 0, 2, 9, 9, 3, 10, 9] \\
Resulting pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[9, 8, 7, 6, 5, 4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[18, 17, 16, 14, 12, 6, 5, 4, 1]}} \\
Map entry count 12304905 \\
Höhe 19 \\


\subsection{PWUE-Zahlen}\label{subsec:pwue-zahlen}
Höhe 1 \\
PWUE of number 1 is 0
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1]}, pancakes=PancakeStackData{pancakes=[1]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1]}, pancakes=PancakeStackData{pancakes=[1]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[]}
Sorter map contains 0 entries
Timings report
Time spend finding PWUE nr 2 ms
Höhe 2 \\
PWUE of number 2 is 1
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 2]}, pancakes=PancakeStackData{pancakes=[1, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1]}, pancakes=PancakeStackData{pancakes=[2]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[0]}
Sorter map contains 1 entries
Timings report
Time spend finding PWUE nr 3 ms
Höhe 3 \\
PWUE of number 3 is 2
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 3, 2]}, pancakes=PancakeStackData{pancakes=[1, 3, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1]}, pancakes=PancakeStackData{pancakes=[3]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[0, 0]}
Sorter map contains 6 entries
Timings report
Time spend finding PWUE nr 84 ms
Höhe 4 \\
PWUE of number 4 is 2
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[4, 1, 3, 2]}, pancakes=PancakeStackData{pancakes=[4, 1, 3, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[2, 1]}, pancakes=PancakeStackData{pancakes=[4, 3]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[1, 1]}
Sorter map contains 6 entries
Timings report
Time spend finding PWUE nr 74 ms
Höhe 5 \\
PWUE of number 5 is 3
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 3, 5, 2, 4]}, pancakes=PancakeStackData{pancakes=[1, 3, 5, 2, 4]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[2, 1]}, pancakes=PancakeStackData{pancakes=[5, 2]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[0, 3, 0]}
Sorter map contains 45 entries
Timings report
Time spend finding PWUE nr 88 ms
Höhe 6 \\
PWUE of number 6 is 3
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[5, 1, 6, 3, 4, 2]}, pancakes=PancakeStackData{pancakes=[5, 1, 6, 3, 4, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[3, 2, 1]}, pancakes=PancakeStackData{pancakes=[3, 2, 1]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[4, 2, 0]}
Sorter map contains 39 entries
Timings report
Time spend finding PWUE nr 88 ms
Höhe 7 \\
PWUE of number 7 is 4
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 5, 7, 3, 4, 6, 2]}, pancakes=PancakeStackData{pancakes=[1, 5, 7, 3, 4, 6, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[3, 2, 1]}, pancakes=PancakeStackData{pancakes=[7, 6, 2]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[1, 0, 2, 1]}
Sorter map contains 297 entries
Timings report
Time spend finding PWUE nr 172 ms
Höhe 8 \\
PWUE of number 8 is 5
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 5, 8, 2, 7, 3, 6, 4]}, pancakes=PancakeStackData{pancakes=[1, 5, 8, 2, 7, 3, 6, 4]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[3, 2, 1]}, pancakes=PancakeStackData{pancakes=[8, 4, 3]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[3, 4, 1, 0, 2]}
Sorter map contains 2463 entries
Timings report
Time spend finding PWUE nr 360 ms
Höhe 9 \\
PWUE of number 9 is 5
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[3, 5, 9, 1, 6, 8, 4, 7, 2]}, pancakes=PancakeStackData{pancakes=[3, 5, 9, 1, 6, 8, 4, 7, 2]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[9, 8, 4, 2]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[1, 0, 5, 2, 1]}
Sorter map contains 2333 entries
Timings report
Time spend finding PWUE nr 1351 ms
Höhe 10 \\
PWUE of number 10 is 6
Example worst case pancake stack PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[1, 6, 2, 9, 5, 8, 4, 7, 10, 3]}, pancakes=PancakeStackData{pancakes=[1, 6, 2, 9, 5, 8, 4, 7, 10, 3]}}
Solved PancakeStack{normalizedPancakes=PancakeStackData{pancakes=[4, 3, 2, 1]}, pancakes=PancakeStackData{pancakes=[8, 7, 6, 3]}}
Flippings operations to solve pancake stack FlippingOrder{flippingOperations=[4, 3, 2, 5, 0, 2]}
Sorter map contains 10429 entries
Timings report
Time spend finding PWUE nr 8870 ms
Höhe 11 \\

Höhe 12 \\
Höhe 13 \\

\section{Quellcode}\label{sec:quellcode}
Unwichtige Teile des Programms sollen hier nicht abgedruckt werden.
Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.

